      SUBROUTINE G2FILE(NAMFIL,NAMPIC,NFOFIL,IOBUFF,
     &                  LENAMF,LENAMP,LENFID,NUMPIC,IOPER,ISTATE)
C
C          ------------------------------------------------
C          ROUTINE NO. (2004)   VERSION (A8.7)    09:AUG:91
C          ------------------------------------------------
C
C          THIS PERFORMS GHOST-80 GRIDFILE HANDLING.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <NAMFIL> THE FILE NAME.
C          <NAMPIC> THE PICTURE NAME.
C          <NFOFIL> THE FILE INFORMATION STRING.
C          <IOBUFF> THE BUFFER BEING READ OR WRITTEN.
C          <LENAMF> THE NO. OF CHARS. IN THE FILE NAME.
C          <LENAMP> THE NO. OF CHARS. IN THE PICTURE NAME.
C          <LENFID> THE NO. OF CHARS. IN THE FILE INFORMATION.
C          <NUMPIC> THE PICTURE NUMBER. THIS IS IGNORED WHEN
C                   WRITING, BUT WHEN READING (IF > 0) THIS
C                   TAKES PRECEDENCE OVER THE PICTURE NAME.
C          <IOPER>  DETERMINES THE OPERATION REQUIRED:
C                   =  1, THE FIRST PICTURE RECORD IS WRITTEN,
C                   =  2, A SUBSEQUENT PICTURE RECORD IS WRITTEN,
C                   =  3, THE NEXT PICTURE RECORD IS READ,
C                   =  4, THE FILE USED AS A SCRATCH FILE IS RESET,
C                   =  5, ALL FILES CURRENTLY OPEN ARE CLOSED, AND
C                         THE SCRATCH FILE (IF IT EXISTS) IS DELETED.
C          <ISTATE> RETURNS THE STATUS OF THE OPERATION:
C                   =  0, IT WAS SUCCESSFUL,
C                   =  1, THE RECORD READ WAS THE LAST RECORD OF THE
C                         CURRENT PICTURE,
C                   =  2, THE RECORD READ WAS THE LAST RECORD IN THE
C                         FILE (TAKES PRECEDENCE OVER <ISTATE>= 1),
C                   =  3, THE FILE REQUESTED FOR READING DOES NOT EXIST,
C                   =  4, THE REQUESTED FILE COULD NOT BE CREATED,
C                   =  5, THE REQUESTED FILE COULD NOT BE OPENED,
C                   =  6, THE REQUESTED FILE COULD NOT BE CLOSED,
C                   =  7, A POSITION ATTEMPT ON THE GIVEN FILE FAILED,
C                   =  8, A READ FAILURE OCCURRED,
C                   =  9, A WRITE FAILURE OCCURRED,
C                   = 10, A WRITE WAS ATTEMPTED ON A READ-ONLY FILE,
C                   = 11, THE PICTURE CURRENTLY READ WAS CORRUPT,
C                   = 12, THE REQUESTED FILE COULD NOT BE DELETED,
C                   = 13, THE PICTURE REQUESTED FOR READING
C                         COULD NOT BE FOUND, AND
C                   = 14, AN INCORRECT FILENAME-LENGTH WAS GIVEN.
C
C
      INTEGER NAMFIL(32),NAMPIC(4),NFOFIL(32),IOBUFF(512),
     &        IDUMMY(1)
      LOGICAL READY,FINPIC,NEWFIL,EXISTS
C
      COMMON /T2BUFF/ IBUFFR(512),INDEXB,IBLOKL
      COMMON /T2HEDR/ IHEADR(1024)
      COMMON /T2IDEN/ IDGRID
      COMMON /T2PHED/ LPIHED
      COMMON /T2RECC/ NBLOKS,NXTBLK,NXTFRE,MAXBLK,FINPIC
      COMMON /T2USEN/ LASTFI(32,2),LASTPI(4)
      COMMON /T2USES/ READY(2),LASTPN,KFILE
      COMMON /T3FILL/ LENDEF,LENSCR
      COMMON /T3FILN/ NAMDEF(32),NAMSCR(32)
      COMMON /T3MACH/ NMCHI,NBITMC
C
      DATA IDUMMY /0/, NULL /0/
C
      IWORD(LEN1)= ((LEN1-1)/NMCHI)+1
C
C
C          IF 'FILE CLOSE' IS REQUIRED, THIS IS PERFORMED BELOW.
C          OTHERWISE, IF A FILE NAME HAS NOT BEEN SUPPLIED, A
C          'NONEXISTENT-FILE' STATUS IS SET AND THE ROUTINE ENDS.
C
      IF (IOPER.GE.5) GO TO 34
C
      ISTATE= 14
      IF (LENAMF.LE.0) RETURN
C
C          IF THERE ARE NO FILES SET UP, THE FIRST IS ALLOCATED.
C          IF ONE HAS BEEN SET UP, THE NEW NAME IS COMPARED WITH
C          THE PREVIOUS ONE, AND IF THEY ARE THE SAME THE FILE
C          NUMBER IS SET = 1 AND THE ROUTINE PROCEEDS. IF THEY
C          ARE NOT THE SAME, FILE NUMBER 2 IS ALLOCATED, IF FREE.
C          IF NOT FREE, AND THE NEW FILE IS NOT THE SAME AS THE
C          PREVIOUS ONE ON THIS CHANNEL, THE FIRST FILE IS CLOSED
C          AND THE NEW FILE IS OPENED ON THAT CHANNEL IN ITS PLACE.
C
      IF (READY(1)) GO TO 1
C
      KFILE= 1
      GO TO 6
C
    1 NEWFIL= .FALSE.
C
      DO 100 LOOK= 1,32
        IF (NAMFIL(LOOK).NE.LASTFI(LOOK,1)) GO TO 2
  100 CONTINUE
C
      KFILE= 1
      GO TO 4
C
    2 IF (READY(2)) GO TO 3
C
      KFILE= 2
      GO TO 6
C
    3 DO 200 LOAD= 1,32
        IF (NAMFIL(LOAD).NE.LASTFI(LOAD,2)) GO TO 5
  200 CONTINUE
C
      KFILE= 2
    4 KOFFST= (KFILE-1)*IBLOKL
      LEN1= MOD(IHEADR(KOFFST+1),256)
      IF (LEN1.GT.0) LEN1= IWORD(LEN1)
      GO TO 11
C
    5 KFILE= 3-KFILE
      CALL G2SYSI(4,KFILE,IDUMMY,IDUMMY,NULL,NULL,ISTATE)
      IF (ISTATE.NE.0) RETURN
C
      READY(KFILE)= .FALSE.
C
C          IF THE GIVEN FILE DOES NOT EXIST AND A READ HAS BEEN
C          REQUESTED, AN ERROR RESULTS AND THE ROUTINE TERMINATES.
C          IF A WRITE IS REQUESTED, THE FILE IS CREATED. IF THE
C          FILE DOES ALREADY EXIST, IT IS CONNECTED FOR READ/WRITE.
C
    6 CALL G2SYSI(1,NULL,NAMFIL,IDUMMY,LENAMF,NULL,ISTATE)
      EXISTS= .FALSE.
      KOFFST= (KFILE-1)*IBLOKL
      IF (ISTATE.EQ.0) EXISTS= .TRUE.
      IF (EXISTS) GO TO 7
      IF (IOPER.EQ.3) RETURN
C
      CALL G2SYSI(2,NULL,NAMFIL,IDUMMY,LENAMF,NULL,ISTATE)
      IF (ISTATE.NE.0) RETURN
C
    7 CALL G2SYSI(3,KFILE,NAMFIL,IDUMMY,LENAMF,NULL,ISTATE)
      IF (ISTATE.NE.0) RETURN
C
C          THE NEW FILE NAME IS THEN SAVED AND THE FLAGS ARE SET.
C          IF THE FILE EXISTED PREVIOUSLY, THE FIRST HEADER RECORD
C          IS READ IN; IF THE FILE HAS JUST BEEN CREATED, AN
C          INITIAL HEADER RECORD IS CREATED AND IMMEDIATELY WRITTEN.
C
      READY(KFILE)= .TRUE.
      NEWFIL= .TRUE.
C
      DO 300 LOAD= 1,32
        LASTFI(LOAD,KFILE)= NAMFIL(LOAD)
  300 CONTINUE
C
      IF (IOPER.NE.3.AND..NOT.EXISTS) GO TO 9
C
      CALL G2SYSI(5,KFILE,IDUMMY,IDUMMY,IBLOKL,1,ISTATE)
      IF (ISTATE.NE.0) RETURN
C
      CALL G2SYSI(6,KFILE,IDUMMY,IHEADR,IBLOKL,KOFFST,ISTATE)
      IF (ISTATE.NE.0) RETURN
C
      LEN1= MOD(IHEADR(KOFFST+1),256)
      IF (LEN1.GT.0) LEN1= IWORD(LEN1)
      GO TO 11
C
    9 DO 400 ICLEAR= 2,IBLOKL
        INDEXH= ICLEAR+KOFFST
        IHEADR(INDEXH)= 0
  400 CONTINUE
C
      LEN1= MAX0(LENFID,0)
      IHEADR(KOFFST+1)= IDGRID+LEN1
      IF (LEN1.GT.0) LEN1= IWORD(LEN1)
C
      IHEADR(KOFFST+3)= 1
      IHEADR(KOFFST+4)= (IBLOKL-LEN1-6)/LPIHED
      IHEADR(KOFFST+6)= 2
      IF (LEN1.LE.0) GO TO 10
C
      DO 500 LOAD= 1,LEN1
        INDEXH= IBLOKL+KOFFST-LEN1+LOAD
        IHEADR(INDEXH)= NFOFIL(LOAD)
  500 CONTINUE
C
   10 CALL G2SYSI(5,KFILE,IDUMMY,IDUMMY,IBLOKL,1,ISTATE)
      IF (ISTATE.NE.0) RETURN
C
      CALL G2SYSI(7,KFILE,IDUMMY,IHEADR,IBLOKL,KOFFST,ISTATE)
      IF (ISTATE.NE.0) RETURN
C
   11 IF (IOPER.NE.3) GO TO 24
C
C          THIS PART READS THE NEXT RECORD FROM THE GIVEN FILE.
C
C          THE FIRST SECTION LOOKS FOR THE PICTURE BY NUMBER.
C
      IF (NUMPIC.LE.0) GO TO 16
C
C          A SEARCH FOR THE HEADER IS NOT NECESSARY IF THE PICTURE
C          NUMBER IS THE SAME AS BEFORE AND THE FILE HAS NOT JUST
C          BEEN OPENED. OTHERWISE, HEADER RECORDS ARE READ IN
C          AND EXAMINED AS NECESSARY UNTIL THE REQUIRED PICTURE
C          NUMBER IS FOUND. IF IT CAN'T BE FOUND, THE STATUS
C          FLAG IS SET AND THE SUBROUTINE ENDS. IF IT CAN, THE
C          FILE IS REPOSITIONED AND THE REQUIRED RECORD READ IN.
C
      IF (.NOT.NEWFIL.AND.NUMPIC.EQ.LASTPN) GO TO 22
C
      LASTPN= NUMPIC
      NOWBLK= 1
      NENDPB= 0
C
C          IF THE HEADER RECORD NUMBER IS 1, THE HEADER HAS ALREADY
C          BEEN READ. THE FILE INFORMATION IS SAVED (FOR RETURNING)
C          WHEN THE FIRST HEADER RECORD IS TAKEN FROM THE GRIDFILE.
C
      IF (IHEADR(KOFFST+3).EQ.1) GO TO 13
C
   12   CALL G2SYSI(5,KFILE,IDUMMY,IDUMMY,IBLOKL,NOWBLK,ISTATE)
        IF (ISTATE.NE.0) RETURN
C
        CALL G2SYSI(6,KFILE,IDUMMY,IHEADR,IBLOKL,KOFFST,ISTATE)
        IF (ISTATE.NE.0) RETURN
C
        LEN1= MOD(IHEADR(KOFFST+1),256)
        IF (LEN1.GT.0) LEN1= IWORD(LEN1)
C
   13   NENDPA= NENDPB
        NENDPB= NENDPB+IHEADR(KOFFST+5)
        IF (NOWBLK.EQ.1) LENFID= MOD(IHEADR(KOFFST+1),256)
        IF (LEN1.LE.0) GO TO 14
C
        DO 600 LOAD= 1,LEN1
          INDEXH= IBLOKL+KOFFST-LEN1+LOAD
          NFOFIL(LOAD)= IHEADR(INDEXH)
  600   CONTINUE
C
C          LOOP-12 CONTINUES UNTIL THE REQUIRED HEADER RECORD
C          HAS BEEN FOUND OR THE PICTURE LIST IS EXHAUSTED,
C          WHICHEVER HAPPENS FIRST. IN THE LATTER CASE, AN
C          ERROR IS FLAGGED AND THE SUBROUTINE GIVES UP.
C
   14   IF (NUMPIC.GT.NENDPA.AND.NUMPIC.LE.NENDPB) GO TO 15
C
        NOWBLK= IHEADR(KOFFST+2)
        IF (NOWBLK.GT.0) GO TO 12
C
      ISTATE= 13
      RETURN
C
C          ONCE THE CORRECT HEADER RECORD HAS BEEN FOUND, THE
C          NUMBER OF THE PICTURE START RECORD IS READ FROM IT.
C
   15 INDEX= (NUMPIC-NENDPA-1)*LPIHED+KOFFST+7
      GO TO 21
C
C          THIS SECTION LOOKS FOR THE PICTURE BY NAME.
C
C          IF THE FILE HAS NOT BEEN NEWLY OPENED AND THE PICTURE NAME
C          IS THE SAME AS BEFORE, THE REQUIRED HEADER RECORD IS THE
C          ONE HELD, AND THE NEXT PICTURE RECORD CAN BE FOUND FROM IT
C          DIRECTLY. OTHERWISE, HEADER RECORDS ARE READ IN FROM THE
C          BEGINNING UNTIL THE REQUIRED PICTURE NAME HAS BEEN FOUND.
C          IF THE END IS REACHED IT IS FOUND, AN ERROR IS FLAGGED.
C
   16 IF (NEWFIL) GO TO 17
C
      DO 700 LOOK= 1,4
        IF (NAMPIC(LOOK).NE.LASTPI(LOOK)) GO TO 17
  700 CONTINUE
      GO TO 22
C
C          IF THE HEADER RECORD NUMBER IS 1, THE HEADER HAS ALREADY
C          BEEN READ. THE FILE INFORMATION IS SAVED (FOR RETURNING)
C          WHEN THE FIRST HEADER RECORD IS TAKEN FROM THE GRIDFILE.
C
   17 DO 800 LOAD= 1,4
        LASTPI(LOAD)= NAMPIC(LOAD)
  800 CONTINUE
C
      NOWBLK= 1
      IF (IHEADR(KOFFST+3).EQ.1) GO TO 19
C
   18   CALL G2SYSI(5,KFILE,IDUMMY,IDUMMY,IBLOKL,NOWBLK,ISTATE)
        IF (ISTATE.NE.0) RETURN
C
        CALL G2SYSI(6,KFILE,IDUMMY,IHEADR,IBLOKL,KOFFST,ISTATE)
        IF (ISTATE.NE.0) RETURN
C
        LEN1= MOD(IHEADR(KOFFST+1),256)
        IF (LEN1.GT.0) LEN1= IWORD(LEN1)
C
   19   NENDPB= IHEADR(KOFFST+5)
        IF (NOWBLK.EQ.1) LENFID= MOD(IHEADR(KOFFST+1),256)
        IF (LEN1.LE.0) GO TO 20
C
        DO 900 LOAD= 1,LEN1
          INDEXH= IBLOKL+KOFFST-LEN1+LOAD
          NFOFIL(LOAD)= IHEADR(INDEXH)
  900   CONTINUE
C
C          LOOP-18 CONTINUES UNTIL THE REQUIRED HEADER RECORD
C          HAS BEEN FOUND OR THE PICTURE LIST IS EXHAUSTED,
C          WHICHEVER HAPPENS FIRST. IN THE LATTER CASE, AN
C          ERROR IS FLAGGED AND THE SUBROUTINE GIVES UP.
C
   20   DO 1000 IPIC= 1,NENDPB
          DO 1100 LOOK= 1,4
            INDEX= (IPIC-1)*LPIHED+KOFFST+LOOK+8
            IF (NAMPIC(LOOK).NE.IHEADR(INDEX)) GO TO 1000
 1100     CONTINUE
C
          INDEX= (IPIC-1)*LPIHED+KOFFST+7
          GO TO 21
 1000   CONTINUE
C
        NOWBLK= IHEADR(KOFFST+2)
        IF (NOWBLK.GT.0) GO TO 18
C
      ISTATE= 13
      RETURN
C
C          ONCE THE CORRECT HEADER RECORD HAS BEEN FOUND, THE
C          NUMBER OF THE PICTURE START RECORD IS READ FROM IT.
C          IF EITHER THE NUMBER OF THE PICTURE START RECORD OR
C          THE NUMBER OF RECORDS IN THE PICTURE IS NOT > 0,
C          THE PICTURE IS INCOMPLETE AND AN ERROR IS FLAGGED.
C
   21 NOWBLK= IHEADR(INDEX)
      NBLOKS= 0
      NXTFRE= IHEADR(KOFFST+6)
      FINPIC= .FALSE.
      IF (IHEADR(KOFFST+2).EQ.0) FINPIC= .TRUE.
C
      MAXBLK= IHEADR(INDEX+1)
      IF (NOWBLK.GT.0.AND.MAXBLK.GT.0) GO TO 23
C
      ISTATE= 11
      RETURN
C
C          THIS PART IS USED TO CHAIN TO THE NEXT PICTURE
C          RECORD WHEN SUCCESSIVE RECORDS OF THE SAME PICTURE
C          (EXCEPTING THE FIRST RECORD) ARE BEING READ IN.
C
   22 NOWBLK= NXTBLK
      IF (NOWBLK.GT.0.AND.MAXBLK.GT.NBLOKS) GO TO 23
C
      ISTATE= 13
      RETURN
C
C          THIS SECTION DOES THE REQUIRED POSITION AND RECORD READ.
C          IF THESE ARE SUCCESSFUL, THE STATUS FLAG IS CLEARED AND
C          THE RECORD NUMBER OF THE FILE UPDATED. IF THIS EXCEEDS
C          THE NO. OF RECORDS IN THE PICTURE, THE STATUS IS SET TO
C          END-OF-PICTURE. IF THE CURRENT HEADER RECORD IS THE LAST
C          AND THERE ARE NO MORE DATA RECORDS, END-OF-FILE IS SET.
C          AT END-OF-PICTURE, THE CURRENT PICTURE NAME AND NUMBER
C          ARE RESET, TO ENSURE THAT POINTERS ARE PROPERLY RESTORED
C          WHEN THE SAME PICTURE IS REQUIRED IMMEDIATELY AFTERWARDS.
C
   23 CALL G2SYSI(5,KFILE,IDUMMY,IDUMMY,IBLOKL,NOWBLK,ISTATE)
      IF (ISTATE.NE.0) RETURN
C
      CALL G2SYSI(6,KFILE,IDUMMY,IOBUFF,IBLOKL,0,ISTATE)
      IF (ISTATE.NE.0) RETURN
C
      ISTATE= 0
      NBLOKS= NBLOKS+1
      NXTBLK= IOBUFF(2)
      IF (MAXBLK.GT.NBLOKS) RETURN
C
      ISTATE= 1
      IF (FINPIC.AND.NXTFRE.EQ.NOWBLK+1) ISTATE= 2
C
      LASTPN= 0
      LASTPI(1)= 0
      RETURN
C
C
   24 IF (IOPER.GT.3) GO TO 32
C
C          THIS PART WRITES THE NEXT RECORD TO THE GIVEN FILE AND
C          UPDATES THE RELEVANT HEADER RECORD ACCORDINGLY. IF THE
C          FILE HAS NOT BEEN FRESHLY OPENED, THE CORRECT HEADER RECORD
C          IS ALREADY STORED. OTHERWISE, THE PROGRAM READS AND CHAINS
C          THROUGH THE HEADER RECORDS UNTIL THE LAST ONE IS FOUND.
C
      IF (.NOT.NEWFIL) GO TO 26
C
   25   NOWBLK= IHEADR(KOFFST+2)
        IF (NOWBLK.EQ.0) GO TO 26
C
        CALL G2SYSI(5,KFILE,IDUMMY,IDUMMY,IBLOKL,NOWBLK,ISTATE)
        IF (ISTATE.NE.0) RETURN
C
        CALL G2SYSI(6,KFILE,IDUMMY,IHEADR,IBLOKL,KOFFST,ISTATE)
        IF (ISTATE.NE.0) RETURN
C
        GO TO 25
C
C          ONCE THE HEADER HAS BEEN FOUND, THE POINTERS
C          TO THE LAST PICTURE OF THE FILE CAN BE FOUND.
C
C          IF THE GIVEN RECORD IS THE FIRST OF A NEW PICTURE,
C          THE PICTURE LIST HAS TO BE UPDATED. OTHERWISE,
C          THE FILE POSITION CAN BE SET, THE PICTURE LENGTH
C          INCREMENTED, AND THE NEW RECORD DIRECTLY WRITTEN.
C
   26 LSTPNW= IHEADR(KOFFST+5)
      INDEX= (LSTPNW-1)*LPIHED+KOFFST+7
      IF (IOPER.EQ.1) GO TO 27
C
      NOWBLK= IHEADR(KOFFST+6)
      IHEADR(INDEX+1)= IHEADR(INDEX+1)+1
      GO TO 30
C
C          IF THERE IS SUFFICIENT ROOM IN THE CURRENT HEADER,
C          IT CAN BE UPDATED DIRECTLY. OTHERWISE, THE NEXT-
C          AVAILABLE RECORD IS ALLOCATED TO A NEW HEADER, AND
C          THE PRESENT HEADER (AFTER AMENDMENT) IS REWRITTEN.
C
   27 IF (LSTPNW.LT.IHEADR(KOFFST+4)) GO TO 29
C
      IHEADR(KOFFST+2)= IHEADR(KOFFST+6)
      IF (IHEADR(KOFFST+2).GT.0) GO TO 28
C
      ISTATE= 11
      RETURN
C
   28 NOWBLK= IHEADR(KOFFST+3)
      CALL G2SYSI(5,KFILE,IDUMMY,IDUMMY,IBLOKL,NOWBLK,ISTATE)
      IF (ISTATE.NE.0) RETURN
C
      CALL G2SYSI(7,KFILE,IDUMMY,IHEADR,IBLOKL,KOFFST,ISTATE)
      IF (ISTATE.NE.0) RETURN
C
C          THE NEW HEADER RECORD IS THEN SET UP WITH A BLANK
C          PICTURE LIST, AND THIS IS APPENDED TO THE GRIDFILE.
C
      IHEADR(KOFFST+1)= IDGRID
      IHEADR(KOFFST+2)= 0
      IHEADR(KOFFST+3)= IHEADR(KOFFST+6)
      IHEADR(KOFFST+4)= (IBLOKL-6)/LPIHED
      IHEADR(KOFFST+6)= IHEADR(KOFFST+3)+1
      LSTPNW= 0
      INDEX= KOFFST+1
C
      DO 1200 ICLEAR= 9,IBLOKL
        INDEXH= ICLEAR+KOFFST
        IHEADR(INDEXH)= 0
 1200 CONTINUE
C
      NOWBLK= IHEADR(KOFFST+3)
      CALL G2SYSI(5,KFILE,IDUMMY,IDUMMY,IBLOKL,NOWBLK,ISTATE)
      IF (ISTATE.NE.0) RETURN
C
      CALL G2SYSI(7,KFILE,IDUMMY,IHEADR,IBLOKL,KOFFST,ISTATE)
      IF (ISTATE.NE.0) RETURN
C
C          THE CURRENT HEADER RECORD IS UPDATED HERE. THE
C          NUMBER OF PICTURES IS INCREMENTED, THE NUMBER
C          OF THE NEXT-AVAILABLE RECORD AMENDED, THE PICTURE
C          START-POSITION SET AND THE PICTURE NAME (IF ONE
C          WAS SUPPLIED) INCLUDED IN THE PICTURE NAME LIST.
C
   29 LSTPNW= LSTPNW+1
      IHEADR(KOFFST+5)= LSTPNW
      INDEX= INDEX+LPIHED
      NOWBLK= IHEADR(KOFFST+6)
      IHEADR(INDEX)= NOWBLK
      IHEADR(INDEX+1)= 1
      IF (LENAMP.LE.0) GO TO 30
C
      DO 1300 LOAD= 1,4
        IPLACE= INDEX+LOAD+1
        IHEADR(IPLACE)= NAMPIC(LOAD)
 1300 CONTINUE
C
C          IF THE NEW RECORD-POSITION IS WRONG, THE HEADER HAS
C          BEEN CORRUPTED: THE ERROR IS FLAGGED AND THE ROUTINE
C          ENDS. OTHERWISE, POINTERS ARE SUITABLY UPDATED, THE
C          FILE POSITIONED, AND THE PICTURE RECORD WRITTEN. IN
C          ORDER TO KEEP THE INTEGRITY OF THE FILE AS HIGH AS
C          POSSIBLE, THE HEADER IS ALWAYS REWRITTEN AFTERWARDS.
C
   30 IF (NOWBLK.GT.0) GO TO 31
C
      ISTATE= 13
      RETURN
C
   31 CALL G2SYSI(5,KFILE,IDUMMY,IDUMMY,IBLOKL,NOWBLK,ISTATE)
      IF (ISTATE.NE.0) RETURN
C
      NOWBLK= NOWBLK+1
      IHEADR(KOFFST+6)= NOWBLK
      IOBUFF(2)= NOWBLK
      CALL G2SYSI(7,KFILE,IDUMMY,IOBUFF,IBLOKL,0,ISTATE)
      IF (ISTATE.NE.0) RETURN
C
      NOWBLK= IHEADR(KOFFST+3)
      CALL G2SYSI(5,KFILE,IDUMMY,IDUMMY,IBLOKL,NOWBLK,ISTATE)
      IF (ISTATE.NE.0) RETURN
C
      CALL G2SYSI(7,KFILE,IDUMMY,IHEADR,IBLOKL,KOFFST,ISTATE)
      RETURN
C
C          THIS SECTION RESETS THE FILE USED AS A SCRATCH FILE
C          BY RESETTING THE FIRST HEADER RECORD POINTERS SO THAT
C          SUBSEQUENT OUTPUT OVERWRITES THE FILE FROM THE START.
C
   32 NOWBLK= 1
C
C          IF THE CURRENT HEADER IS NOT THE FIRST, THE FIRST
C          IS READ IN. THE HEADER IS THEN RESET AND REWRITTEN.
C
      IF (IHEADR(KOFFST+3).EQ.1) GO TO 33
C
      CALL G2SYSI(5,KFILE,IDUMMY,IDUMMY,IBLOKL,NOWBLK,ISTATE)
      IF (ISTATE.NE.0) RETURN
C
      CALL G2SYSI(6,KFILE,IDUMMY,IHEADR,IBLOKL,KOFFST,ISTATE)
      IF (ISTATE.NE.0) RETURN
C
   33 IHEADR(KOFFST+2)= 0
C
      DO 1400 ICLEAR= 5,IBLOKL
        INDEXH= ICLEAR+KOFFST
        IHEADR(INDEXH)= 0
 1400 CONTINUE
C
      IHEADR(KOFFST+6)= 2
      CALL G2SYSI(5,KFILE,IDUMMY,IDUMMY,IBLOKL,NOWBLK,ISTATE)
      IF (ISTATE.NE.0) RETURN
C
      CALL G2SYSI(7,KFILE,IDUMMY,IHEADR,IBLOKL,KOFFST,ISTATE)
      RETURN
C
C          THIS SECTION CLOSES ALL FILES CURRENTLY OPEN,
C          THEN DELETES THE SCRATCH FILE IF IT EXISTS.
C
   34 CALL G2SYSI(4,0,IDUMMY,IDUMMY,NULL,NULL,ISTATE)
      IF (ISTATE.NE.0) RETURN
C
      READY(1)= .FALSE.
      READY(2)= .FALSE.
      CALL G2SYSI(1,NULL,NAMSCR,IDUMMY,LENSCR,NULL,ISTATE)
      IF (ISTATE.EQ.0) GO TO 35
C
      ISTATE= 0
      RETURN
C
   35 CALL G2SYSI(8,NULL,NAMSCR,IDUMMY,LENSCR,NULL,ISTATE)
      RETURN
      END
