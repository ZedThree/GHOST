      SUBROUTINE G1TRAN(INBUFR,ISTART,IEND)
C
C          ------------------------------------------------
C          ROUTINE NO. (1003)   VERSION (A8.1APC) 14:JUL:97
C          ------------------------------------------------
C
C          THIS CONVERTS PAIRS OF VALUES IN THE INPUT BUFFER
C          INTO CODES SUITABLE FOR DRIVING THE OUTPUT DEVICE.
C          (THIS VERSION IS FOR ADOBE COLOUR POSTSCRIPT).
C
C
C          THE FUNCTIONS SUPPORTED HERE (GIVEN BY
C          THE X-VALUE OF ANY PAIR) ARE AS FOLLOWS:
C
C          =  -1, PLOT (AT THE CURRENT POSITION) A POINT,
C          =  -2, DRAW (AT THE CURRENT POS.) CHAR. <IYVAL>,
C              .
C          = -11, SET POSTSCRIPT CHARACTER SIZE    <IYVAL>,
C          = -12, SET POSTSCRIPT CHARACTER ANGLE   <IYVAL>,
C          = -13, SET POSTSCRIPT CHARACTER FONT    <IYVAL>,
C          = -14, SET POSTSCRIPT CHARACTER OBLATE  <IYVAL>,
C              .
C          = -17, SET COLOUR NUMBER                <IYVAL>,
C          = -18, FILL POLYGON                     <IYVAL>,
C              .
C          = -20, BEGIN FILLED-AREA BOUNDARY       <IYVAL>,
C          = -21, SET PLOT ORIENTATION             <IYVAL>,
C              .
C          = -40, PASS DATA DIRECTLY TO THE DEVICE <IDATA>,
C              .
C          = -42, DEFINE HARDWARE LINE TYPE        <IDATA>,
C              .
C          = -44, SET PARAMETERS FOR CROSS HATCHING,
C              .
C          = -81, ERASE THE DEVICE WITH PROMPT/WAIT,
C          = -82, ERASE THE DEVICE WITHOUT PROMPT/WAIT,
C              .
C          = -84, CLEAR THE SYSTEM BUFFER,
C          = -85, END GRAPHICAL OUTPUT.
C
C
      INTEGER INBUFR(IEND),IDUMMY(1),ICODES(16),ITRAIL(10),IBYTE(5),
     &        IPTRAL(14)
      REAL    FNTMUL(13)
      LOGICAL BOUND
C
      COMMON /T1APAA/ IXPLOT,IYPLOT,IXMSAV,IYMSAV,LENPTH,MAXPTH,
     &                IDLLX,IDLLY,IDURX,IDURY,IPLLX,IPLLY,IPURX,IPURY
      COMMON /T1APCB/ CHIGHT,ZOBLAT,IREDPO(255),IGRNPO(255),IBLUPO(255),
     &                KOLOUR,IPAGE(17),IPGCNT,IPBBOX(26),IDBOX(14),
     &                IPBOX(18)
      COMMON /T1DLIM/ DLIMX,DLIMY
      COMMON /T1DRES/ DRESX,DRESY
      COMMON /T1FLBF/ IXSAVE(1000),IYSAVE(1000),ISAVSZ,INDSAV
      COMMON /T1FLSV/ BOUND
      COMMON /T1FUND/ NUMFUN,LENARG
      COMMON /T1HTCH/ IHTCHP(11,2)
      COMMON /T1IOBF/ ICODEB(512),ISIZEB,INDXB,INITXB
      COMMON /T1LAND/ LNDSCP
C
      SAVE INDFNT
C
      DATA IDUMMY /  0/, IBLANK / 32/, LPAREN / 40/, IRPARN / 41/,
     &     MINUS  / 45/, IPOINT / 46/, IZERO  / 48/,
     &     LETTRC / 67/, LETTRP / 80/, IBSLSH / 92/,
     &     LETTSB / 98/, LETTSC / 99/, LETTSF /102/, LETTSH /104/,
     &     LETTSP /112/, LETTSR /114/, LETTSS /115/, LETTSW /119/,
     &     LETTSX /120/,
     &     IHTCOL /  2/, IHTYPE / 11/, ICODES /16*32/, INDFNT /1/
C
C          ARRAYS ARE INITIALISED TO:
C
C  ITRAIL  %%Trailer
C  IPTRAL  %%PageTrailer
C
      DATA ITRAIL /37,37,84,114,97,105,108,101,114,32/
      DATA IPTRAL /37,37,80,97,103,101,84,114,97,105,108,101,114,32/
C
      DATA FNTMUL /1.512,1.533,1.481,1.494,1.393,1.393,1.393,
     &             1.393,1.779,1.779,1.779,1.779,1.486/
C
C
C          EACH PAIR OF VALUES IS TAKEN IN TURN FROM THE
C          SUPPLIED BUFFER, THE REQUIRED ACTION IS DECODED,
C          THEN THE APPROPRIATE COMMANDS FOR THE DISPLAY ARE
C          STORED IN A LINE OUTPUT BUFFER, WHICH IS EMPTIED
C          (THE CONTENTS BEING SENT TO THE DISPLAY) WHEN FULL.
C
C          IF <LENARG> IS NON-ZERO, A FUNCTION IS STILL ACTIVE.
C          THE BUFFER PAIR IS THEN PASSED ON DIRECTLY TO THE
C          RELEVANT FUNCTION. OTHERWISE, IF <IXVAL> < 0, A
C          NEW FUNCTION IS REQUIRED, OR IF <IXVAL> > 0, A
C          VECTOR (VISIBLE OR INVISIBLE) IS REQUIRED INSTEAD.
C
      DO 100 IPAIR= ISTART,IEND,2
        IXVAL= INBUFR(IPAIR)
        IYVAL= INBUFR(IPAIR+1)
        IF (LENARG.GT.0) GO TO 42
        IF (IXVAL.LT.0)  GO TO 2
        IF (BOUND)       GO TO 35
C
C          THE FIRST PART PROVIDES VECTOR DRAWING. IF
C          <IYVAL> < 0, THE LINE IS NOT VISIBLE, AND THE
C          Y-VALUE HAS TO BE APPROPRIATELY READJUSTED.
C
        IF (IYVAL.GE.0) GO TO 1
C
        IXMSAV= IXVAL
        IYMSAV= -IYVAL-1
        GO TO 100
C
    1   CALL G1VECT(IXVAL,IYVAL,1)
        GO TO 100
C
C          THE REMAINDER OF THE ROUTINE IS FOR SPECIAL FUNCTIONS.
C          THE FUNCTION TYPE IS DETERMINED BY <IXVAL> AS FOLLOWS:
C
C          IF <IXVAL>= -1, A POINT IS PLOTTED.
C          (A ZERO LENGTH VECTOR WITH ROUNDED ENDS IS DRAWN).
C
    2   IF (IXVAL.NE.-1) GO TO 3
C
	CALL G1VECT(IXMSAV,IYMSAV,3)
        ICODES(2)= LETTRP
        CALL G1BUFF(ICODES,2)
        LENPTH= 0
        GO TO 100
C
    3   IF (LENPTH.EQ.0) GO TO 4
C
        ICODES(2)= LETTSS
        CALL G1BUFF(ICODES,2)
        LENPTH= 0
C
C          IF <IXVAL>= -2, A HARDWARE CHARACTER IS DRAWN
C          AFTER THE POSITION HAS BEEN SET PREVIOUSLY.
C
    4   IF (IXVAL.NE.-2) GO TO 6
C
        CALL G1VECT(IXMSAV,IYMSAV,3)
        ICODES(2)= LPAREN
        IF (IYVAL.LT.127) THEN
          INDEX= 5
          IF (IYVAL.NE.LPAREN.AND.IYVAL.NE.IRPARN.AND.IYVAL.NE.IBSLSH)
     &        GO TO 5
C
          ICODES(3)= IBSLSH
          INDEX= 6
    5     ICODES(INDEX-2)= IYVAL
        ELSE
          INDEX=8
          ICODES(3)= IBSLSH
          ICODES(4)= IZERO+IYVAL/64
          IYVAL= IYVAL-(ICODES(4)-IZERO)*64
          ICODES(5)= IZERO+IYVAL/8
          ICODES(6)= IZERO+IYVAL-(ICODES(5)-IZERO)*8
        ENDIF
C
        ICODES(INDEX-1)= IRPARN
        ICODES(INDEX)= LETTSC
        CALL G1BUFF(ICODES,INDEX)
        LENPTH= 0
        GO TO 100
C
C          IF <IXVAL>= -11, POSTSCRIPT CHARACTER SIZE IS SET.
C
    6   IF (IXVAL.NE.-11) GO TO 8
C
        CHIGHT= IYVAL
        INDEX= 1
        IVCTOR= CHIGHT*FNTMUL(INDFNT)
        IFROM= 1
        GO TO 66
C
    7   INDEX= INDEX+4
        ICODES(INDEX-3)= IBLANK
        ICODES(INDEX-2)= LETTSS
        ICODES(INDEX-1)= LETTSC
        ICODES(INDEX)= LETTSH
        CALL G1BUFF(ICODES,INDEX)
        GO TO 12
C
C          IF <IXVAL>= -12, POSTSCRIPT CHARACTER ROTATION IS SET.
C
    8   IF (IXVAL.NE.-12) GO TO 10
C
        INDEX= 1
        IVCTOR= IYVAL
        IF (LNDSCP.EQ.0) IVCTOR= IVCTOR+90
C
        IFROM= 2
        GO TO 66
C
    9   INDEX= INDEX+4
        ICODES(INDEX-3)= IBLANK
        ICODES(INDEX-2)= LETTSS
        ICODES(INDEX-1)= LETTSC
        ICODES(INDEX)= LETTSR
        CALL G1BUFF(ICODES,INDEX)
        GO TO 100
C
C          IF <IXVAL>= -13, POSTSCRIPT CHAR. FONT IS SET.
C
   10   IF (IXVAL.NE.-13) GO TO 11
C
        INDFNT= IYVAL+1
        IF (IYVAL.LE.9) THEN
          ICODES(2)= IZERO+IYVAL
          INDEX= 6
        ELSE
          ICODES(2)= IZERO+(IYVAL/10)
          ICODES(3)= IZERO+MOD(IYVAL,10)
          INDEX= 7
        ENDIF
C
        ICODES(INDEX-3)= IBLANK
        ICODES(INDEX-2)= LETTSS
        ICODES(INDEX-1)= LETTSC
        ICODES(INDEX)= LETTSS
        CALL G1BUFF(ICODES,INDEX)
        GO TO 100
C
C          IF <IXVAL>= -14, HARDWARE CHAR. OBLATENESS IS SET.
C
   11   IF (IXVAL.NE.-14) GO TO 14
C
        ZOBLAT= IYVAL/1000.0
   12   INDEX= 1
        IVCTOR= ZOBLAT*CHIGHT*FNTMUL(INDFNT)
        IFROM= 3
        GO TO 66
C
   13   INDEX= INDEX+4
        ICODES(INDEX-3)= IBLANK
        ICODES(INDEX-2)= LETTSS
        ICODES(INDEX-1)= LETTSC
        ICODES(INDEX)= LETTSW
        CALL G1BUFF(ICODES,INDEX)
        GO TO 100
C
C          IF <IXVAL>= -15, A HARDWARE BROKEN LINE IS SET.
C          (IT IS NOT IMPLEMENTED IN THIS VERSION).
C
   14   IF (IXVAL.NE.-15) GO TO 15
        GO TO 100
C
C          IF <IXVAL>= -16, HARDWARE INTENSITY IS SET.
C          (IT IS NOT IMPLEMENTED IN THIS VERSION).
C
   15   IF (IXVAL.NE.-16) GO TO 16
        GO TO 100
C
C          IF <IXVAL>= -17, THE COLOUR NUMBER IS SET.
C
   16   IF (IXVAL.NE.-17) GO TO 24
C
        KOLOUR= IYVAL
        IFROM= 1
   17   KOL= IREDPO(KOLOUR)
        INDEX= 4
        IF (KOL.NE.0.AND.KOL.LT.100) GO TO 18
C
        ICODES(2)= IZERO+(KOL/100)
        GO TO 19
C
   18   ICODES(2)= IPOINT
        ICODES(3)= IZERO+KOL/10
        ICODES(4)= IZERO+MOD(KOL,10)
        INDEX= 6
   19   ICODES(INDEX-1)= IBLANK
        KOL= IGRNPO(KOLOUR)
        IF (KOL.NE.0.AND.KOL.LT.100) GO TO 20
C
        ICODES(INDEX)= IZERO+(KOL/100)
        GO TO 21
C
   20   ICODES(INDEX)= IPOINT
        ICODES(INDEX+1)= IZERO+KOL/10
        ICODES(INDEX+2)= IZERO+MOD(KOL,10)
        INDEX= INDEX+2
   21   ICODES(INDEX+1)= IBLANK
        KOL= IBLUPO(KOLOUR)
        INDEX= INDEX+4
        IF (KOL.NE.0.AND.KOL.LT.100) GO TO 22
C
        ICODES(INDEX-2)= IZERO+(KOL/100)
        GO TO 23
C
   22   ICODES(INDEX-2)= IPOINT
        ICODES(INDEX-1)= IZERO+KOL/10
        ICODES(INDEX)= IZERO+MOD(KOL,10)
        INDEX= INDEX+2
   23   ICODES(INDEX-1)= IBLANK
        ICODES(INDEX)= LETTRC
        CALL G1BUFF(ICODES,INDEX)
        GO TO (100,28,30,32), IFROM
C
C          IF <IXVAL>= -18, A POLYGON FILL IS DONE.
C
   24   IF (IXVAL.NE.-18) GO TO 33
        IF (INDSAV.GT.0) GO TO 25
C
        BOUND= .FALSE.
        GO TO 100
C
C          THIS PART CLOSES THE BOUNDARY IF IT IS OPEN.
C
   25   IF (IXSAVE(1).EQ.IXSAVE(INDSAV).AND.
     &      IYSAVE(1).EQ.IYSAVE(INDSAV)) GO TO 26
C
        CALL G1DISC(IXSAVE(1),IYSAVE(1))
   26   IF (IHTCHP(IHTYPE,2).NE.0) GO TO 27
C
C          THIS SECTION IS FOR SOLID AREA FILL
C          THIS PART DEFINES THE AREA BOUNDARY.
C
        CALL G1VECT(IXSAVE(1),IYSAVE(1),3)
C
        DO 200 INDOUT= 2,INDSAV
          CALL G1VECT(IXSAVE(INDOUT),IYSAVE(INDOUT),2)
  200   CONTINUE
C
C          THIS PART FILLS THE GIVEN AREA.
C
        ICODES(2)= LETTSF
        CALL G1BUFF(ICODES,2)
        LENPTH= 0
        GO TO 32
C
   27   IF (IHTCHP(IHTYPE,1).LE.0) GO TO 32
C
C          THIS SECTION IS FOR CROSS-HATCHING.
C
        KOLSAV= KOLOUR
        IF (MOD(IHTCHP(IHTYPE,1),2).NE.1) GO TO 29
C
        IFROM= 2
        KOLOUR= IHTCHP(IHTCOL,1)
        GO TO 17
C
   28   CALL G1SHAD(1)
   29   IF (IHTCHP(IHTYPE,1)/2.NE.1) GO TO 31
C
        IFROM= 3
        KOLOUR= IHTCHP(IHTCOL,2)
        GO TO 17
C
   30   CALL G1SHAD(2)
   31   IFROM= 4
        KOLOUR= KOLSAV
        GO TO 17
C
   32   BOUND= .FALSE.
        GO TO 100
C
C          IF <IXVAL>= -19, DEVICE RESOLUTION IS SET.
C          (IT IS NOT IMPLEMENTED IN THIS VERSION).
C
   33   IF (IXVAL.NE.-19) GO TO 34
        GO TO 100
C
C          IF <IXVAL>= -20, A FILLED AREA BOUNDARY IS BEGUN.
C
   34   IF (IXVAL.NE.-20) GO TO 38
        IF (IYVAL.GT.0) IHTCHP(IHTYPE,2)= 0
C
        BOUND= .TRUE.
        INDSAV= 0
        GO TO 100
C
   35   IF (IYVAL.GE.0) GO TO 36
C
        IYVAL= -IYVAL-1
        IF (INDSAV.EQ.0) GO TO 37
C
        CALL G1DISC(IXVAL,IYVAL)
        GO TO 100
C
C          IF THE BOUNDARY STARTS WITH A JOIN,
C          THE CURRENT POSITION IS SAVED FIRST.
C
   36   IF (INDSAV.GT.0) GO TO 37
C
        INDSAV= 1
        IXSAVE(1)= IXMSAV
        IYSAVE(1)= IYMSAV
   37   IF (INDSAV+3.GE.ISAVSZ) GO TO 100
C
        INDSAV= INDSAV+1
        IXSAVE(INDSAV)= IXVAL
        IYSAVE(INDSAV)= IYVAL
        GO TO 100
C
C          IF <IXVAL>= -21, PLOT ORIENTATION IS SET.
C
   38   IF (IXVAL.NE.-21) GO TO 39
        IF (IYVAL.EQ.LNDSCP) GO TO 100
C
C          SWAP ALL RELEVANT VALUES
C
        LNDSCP= IYVAL
        DLMTMP= DLIMX
        DLIMX= DLIMY
        DLIMY= DLMTMP
        GO TO 100
C
C          IF <IXVAL>= -22, PEN VELOCITY IS SET.
C          (IT IS NOT IMPLEMENTED IN THIS VERSION).
C
   39   IF (IXVAL.NE.-22) GO TO 40
        GO TO 100
C
C          FUNCTION CODES -23 TO -39 ARE NOT YET DEFINED,
C          AND ARE RESERVED FOR FUTURE NON-ARGUMENT FUNCTIONS.
C
   40   IF (IXVAL.LE.-40) GO TO 41
        GO TO 100
C
C          FUNCTION CODES -40 TO -80 ARE ARGUMENT FUNCTIONS.
C          -<IYVAL> GIVES THE LENGTH OF THE ARGUMENT STRING.
C          <NUMFUN> STORES THE FUNCTION CODE CURRENTLY ACTIVE.
C
   41   IF (IXVAL.LT.-80) GO TO 50
C
        NUMFUN= IXVAL
        LENARG= -IYVAL
        GO TO 100
C
C          THIS SECTION DEALS WITH ARGUMENT-FUNCTIONS.
C          NOTE THAT <NUMFUN> IS USED INSTEAD OF <IXVAL>.
C
   42   LENARG= LENARG-1
C
C          IF <NUMFUN>= -40, DATA IS PASSED ON TRANSPARENTLY.
C
        IF (NUMFUN.NE.-40) GO TO 43
C
        ICODES(1)= IXVAL
        ICODES(2)= IYVAL
        CALL G1BUFF(ICODES,2)
        ICODES(1)= IBLANK
        GO TO 100
C
C          IF <NUMFUN>= -41, A COLOUR TABLE ENTRY IS SET.
C          (IT IS NOT IMPLEMENTED IN THIS VERSION).
C
   43   IF (NUMFUN.NE.-41) GO TO 44
        GO TO 100
C
C          IF <NUMFUN>= -42, HARDWARE LINE TYPE IS SET.
C
   44   IF (NUMFUN.NE.-42) GO TO 48
        IF (LENARG.EQ.0) GO TO 45
C
        ICODES(2)= LETTSB
        CALL G1BUFF(ICODES,2)
   45   INDEX= 1
        IVCTOR= IXVAL
        IFROM= 4
        GO TO 66
C
   46   INDEX= INDEX+1
        ICODES(INDEX)= IBLANK
        IVCTOR= IYVAL
        IFROM= 5
        GO TO 66
C
   47   CALL G1BUFF(ICODES,INDEX)
        GO TO 100
C
C          IF <NUMFUN>= -43, BACKGROUND COLOUR IS SET.
C          (IT IS NOT IMPLEMENTED IN THIS VERSION).
C
   48   IF (NUMFUN.NE.-43) GO TO 49
        GO TO 100
C
C          IF <NUMFUN>= -44, SET HATCHING PARAMETERS.
C
   49   IF (NUMFUN.NE.-44) GO TO 100
C
        IHATPT= 11-LENARG
        IHTCHP(IHATPT,1)= IXVAL
        IHTCHP(IHATPT,2)= IYVAL
        GO TO 100
C
C          FOR FUNCTION CODES <= -81, THE LINE BUFFER IS
C          EMPTIED IMMEDIATELY, THEN THE FUNCTION IS DONE.
C
   50   IF (INDXB.GT.INITXB) CALL G1DVIO(3,ICODEB,INDXB-1)
C
        INDXB= INITXB
C
C          IF <IXVAL>= -81, AN ERASE WITH PROMPT IS DONE.
C          (THIS IS DONE IN THE SAME WAY AS THE NEXT ERASE).
C
        IF (IXVAL.NE.-81) GO TO 51
        GO TO 52
C
C          IF <IXVAL>= -82, AN ERASE WITHOUT PROMPT IS DONE.
C
   51   IF (IXVAL.NE.-82) GO TO 57
C
   52   ICODES(2)= LETTSP
        CALL G1DVIO(3,ICODES,2)
        CALL G1DVIO(3,IPTRAL,14)
        CALL G1BUFF(IPBOX,18)
        IF (LNDSCP.EQ.0) THEN
          IXLT= INT(DLIMY*DRESY)-IPURY
          IYLT= IPLLX
          IXHT= INT(DLIMY*DRESY)-IPLLY
          IYHT= IPURX
        ELSE
          IXLT= IPLLX
          IYLT= IPLLY
          IXHT= IPURX
          IYHT= IPURY
        ENDIF
C
        IPLLX= DLIMX*DRESX+1
        IPLLY= DLIMY*DRESY+1
        IPURX= -1
        IPURY= -1
        INDEX= 1
        IVCTOR= IXLT*0.24+18
        IFROM= 6
        GO TO 66
C
   53   INDEX= INDEX+1
        ICODES(INDEX)= IBLANK
        IVCTOR= IYLT*0.24+18
        IFROM= 7
        GO TO 66
C
   54   INDEX= INDEX+1
        ICODES(INDEX)= IBLANK
        IVCTOR= IXHT*0.24+19
        IFROM= 8
        GO TO 66
C
   55   INDEX= INDEX+1
        ICODES(INDEX)= IBLANK
        IVCTOR= IYHT*0.24+19
        IFROM= 9
        GO TO 66
C
   56   CALL G1BUFF(ICODES,INDEX)
        CALL G1DVIO(3,ICODEB,INDXB-1)
        INDXB= INITXB
        IPGCNT= IPGCNT+1
        IPAGE(17)= IZERO+MOD(IPGCNT,10)
        ITEMP= IPGCNT/10
        IPAGE(16)= IZERO+MOD(ITEMP,10)
        IPAGE(15)= IZERO+ITEMP/10
        CALL G1DVIO(3,IPAGE,17)
        CALL G1DVIO(3,IPBBOX,26)
        GO TO 100
C
C          IF <IXVAL>= -83, THE CURSOR IS DISPLAYED.
C          (IT IS NOT IMPLEMENTED IN THIS VERSION).
C
   57   IF (IXVAL.NE.-83) GO TO 58
        GO TO 100
C
C          IF <IXVAL>= -84, THE LINE BUFFER IS CLEARED
C          WITHOUT ANY ADDITIONAL ACTION BEING TAKEN.
C
   58   IF (IXVAL.NE.-84) GO TO 59
        GO TO 100
C
C          IF <IXVAL>= -85, GRAPHICAL OUTPUT IS ENDED.
C
   59   IF (IXVAL.NE.-85) GO TO 64
C
        CALL G1DVIO(3,ITRAIL,10)
        CALL G1BUFF(IDBOX,14)
        IF (LNDSCP.EQ.0) THEN
          IXLT= INT(DLIMY*DRESY)-IDURY
          IYLT= IDLLX
          IXHT= INT(DLIMY*DRESY)-IDLLY
          IYHT= IDURX
        ELSE
          IXLT= IDLLX
          IYLT= IDLLY
          IXHT= IDURX
          IYHT= IDURY
        ENDIF
C
        INDEX= 1
        IVCTOR= IXLT*0.24+18
        IFROM= 10
        GO TO 66
C
   60   INDEX= INDEX+1
        ICODES(INDEX)= IBLANK
        IVCTOR= IYLT*0.24+18
        IFROM= 11
        GO TO 66
C
   61   INDEX= INDEX+1
        ICODES(INDEX)= IBLANK
        IVCTOR= IXHT*0.24+19
        IFROM= 12
        GO TO 66
C
   62   INDEX= INDEX+1
        ICODES(INDEX)= IBLANK
        IVCTOR= IYHT*0.24+19
        IFROM= 13
        GO TO 66
C
   63   CALL G1BUFF(ICODES,INDEX)
        CALL G1DVIO(3,ICODEB,INDXB-1)
        INDXB= INITXB
        ICODES(2)= LETTSX
        CALL G1DVIO(3,ICODES,2)
        CALL G1DVIO(2,IDUMMY,1)
        GO TO 100
C
C          IF <IXVAL>= -86, THE REQUIRED CHANNEL IS OPENED.
C          (IT IS NOT IMPLEMENTED IN THIS VERSION).
C
   64   IF (IXVAL.NE.-86) GO TO 65
        GO TO 100
C
C          IF <IXVAL>= -87, THE REQUIRED CHANNEL IS CLOSED.
C          (IT IS NOT IMPLEMENTED IN THIS VERSION).
C
   65   IF (IXVAL.NE.-87) GO TO 100
        GO TO 100
C
C          THIS IS AN INTERNAL SUBROUTINE TO CALCULATE THE PLOT
C          CODES FOR A VECTOR AND PUT THEM IN THE OUTPUT BUFFER.
C
   66   IF (IVCTOR.GE.0) GO TO 67
C
        INDEX= INDEX+1
        ICODES(INDEX)= MINUS
        IVCTOR= -IVCTOR
C
C          THE APPROPRIATE FIVE BYTES ARE CALCULATED (LOW -> HIGH
C          ORDER) AND PLACED IN THE BUFFER IN HIGH -> LOW ORDER.
C
   67   DO 300 I= 1,5
          IDIVSN= IVCTOR/10
          IBYTE(I)= IVCTOR-IDIVSN*10
          INDXBT= I
          IVCTOR= IDIVSN
          IF (IDIVSN.EQ.0) GO TO 68
  300   CONTINUE
C
   68   DO 400 I= 1,INDXBT
          IPOS1= INDEX+I
          IPOS2= INDXBT-I+1
          ICODES(IPOS1)= IBYTE(IPOS2)+IZERO
  400   CONTINUE
C
        INDEX= INDEX+INDXBT
C
C          CONTROL ALWAYS RETURNS TO THE ORIGINATING SECTION
C
        GO TO (7,9,13,46,47,53,54,55,56,60,61,62,63), IFROM
  100 CONTINUE
C
      RETURN
      END
