      SUBROUTINE TYPEST(PHRASE)
C
C          ------------------------------------------------
C          ROUTINE NO. ( 170)   VERSION (A8.5)    11:NOV:92
C                         === FORTRAN-77 ===
C          ------------------------------------------------
C
C          THIS DRAWS THE CHARACTER STRING STORED IN <PHRASE>
C          WITH THE LEFTMOST CHARACTER PLACED AT THE CURRENT
C          CHAR. POSITION. TEXT MAY ALSO BE IN NUMBERED-CHARACTER
C          FORM, AND COMMAND STRINGS MAY BE EMBEDDED IN THE TEXT.
C
C          THIS VERSION IS SUITABLE FOR ANY TYPE OF CHAR. CODING.
C
C
      REAL      RARG(9),RDATA(1)
      INTEGER   ICODE(2,14),IDATA(255),IARG(10),ICOMND(2)
      LOGICAL   ERRON
      LOGICAL   SHOW,CHANGD,END,UPPER,LOWER,NUMBRD,CHDONE
      CHARACTER PHRASE*(*)
C
      COMMON /T0COMS/ NOWCOM,NOWNUM
      COMMON /T0TRAC/ IPRINT
      COMMON /T3ERRS/ ERRON,NUMERR
      COMMON /T3MACH/ NMCHI,NBITMC
      COMMON /T3MACR/ NMCHR
C
C          THE COMMANDS HELD IN [ICODE] ARE:
C
C          BC, CO, FO, IT, LC, MA, NO,
C          OB, RE, SF, SP, TH, UC, UL.
C
      DATA ICODE /66,67, 67,79, 70,79, 73,84, 76,67, 77,65, 78,79,
     &            79,66, 82,69, 83,70, 83,80, 84,72, 85,67, 85,76/,
     &     RDATA /0.0/
C
C
      SHOW= .FALSE.
      CHANGD= .FALSE.
      END= .FALSE.
      LOWER= .FALSE.
      UPPER= .FALSE.
      NUMBRD= .FALSE.
      CHDONE= .FALSE.
      IPRSAV= IPRINT
      IPRINT= 0
      NCHRS= LEN(PHRASE)
      IF (NCHRS.GE.255) GO TO 901
C
C          THE MACHINE CHARACTERS ARE COPIED AND
C          CONVERTED INTO UNPACKED GHOST CHARACTERS.
C
    1 DO 100 KCHAR= 1,NCHRS
        NCHAR= ICHAR(PHRASE(KCHAR:KCHAR))
        CALL G4COCO(NCHAR,IDATA(KCHAR))
  100 CONTINUE
C
C          THIS SECTION OUTPUTS CHARACTERS UNTIL A CONTROL SEQUENCE
C          OR THE END OF THE STRING IS FOUND. IT DETECTS NUMBERED-
C          CHARACTER SEQUENCES AND TRANSLATES CHARACTERS AS NECESSARY.
C
      IHERE= 0
      LIMIT= 0
    2   IHERE= IHERE+1
        IF (IHERE.GT.NCHRS) GO TO 18
C
        KCHAR= IDATA(IHERE)
C
C          IF AN ERROR CONDITION EXISTS THE REMAINING TEXT IS PRINTED.
C
        IF (SHOW) GO TO 9
C
C          A SINGLE COMMAND SWITCH-CHARACTER SETS COMMAND MODE;
C          A PAIR IS TREATED AS A SINGLE PRINTING CHARACTER.
C
        IF (KCHAR.NE.NOWCOM) GO TO 3
C
        IHERE= IHERE+1
        IF (IHERE.GT.NCHRS) GO TO 18
C
        KCHAR= IDATA(IHERE)
        IF (KCHAR.EQ.NOWCOM) GO TO 9
        GO TO 10
C
C          IF A SWITCH-CHARACTER FOR NUMBERED-CHARACTER MODE IS FOUND,
C          IF NUMBERED-CHARACTER MODE IS SET, THIS IS DISABLED. IF IT
C          IS NOT SET, THE NEXT CHARACTER IS EXAMINED TO SEE IF THERE
C          IS A PAIR, WHICH IS TREATED AS A SINGLE PRINTING CHARACTER.
C          IF THE END OF THE STRING IS ENCOUNTERED, NO MORE IS DONE.
C
    3   IF (KCHAR.NE.NOWNUM) GO TO 5
        IF (NUMBRD) GO TO 4
C
        IHERE= IHERE+1
        IF (IHERE.GT.NCHRS) GO TO 18
C
        KCHAR= IDATA(IHERE)
        IF (KCHAR.EQ.NOWNUM) GO TO 5
C
        IHERE= IHERE-1
   4    NUMBRD= .NOT.NUMBRD
        GO TO 2
C
C          IN NUMBERED-CHARACTER MODE, DIGIT STRINGS ARE CONVERTED,
C          BUT ANY SEPARATORS (EXCLUDING CHARACTERS) ARE IGNORED.
C          AN ERROR EXISTS IF THE DIGIT VALUE IS GREATER THAN 255.
C
    5   IF (SHOW)        GO TO 9
        IF (.NOT.NUMBRD) GO TO 7
C
        CALL G4NEXC(IDATA,IHERE,NCHRS,NCHRS,-2,IPOSS)
        IF (IPOSS.LE.0) IPOSS= NCHRS+1
C
        CALL G4NEXC(IDATA,IHERE,NCHRS,NCHRS,+2,IPOSN)
        IF (IPOSN.LE.0) IPOSN= NCHRS+1
        IF (IPOSS.LT.IPOSN) GO TO 6
C
        CALL G4NEXI(IDATA,IHERE,NCHRS,NCHRS,IVALUE,LENGTH,IPOSN)
        IF (IVALUE.LT.0) IVALUE= IVALUE+1
        IF (IVALUE.GT.255) GO TO 902
C
        KCHAR= MOD(IABS(IVALUE),256)
        IHERE= IPOSN-1
        IF (IHERE.LT.0) IHERE= NCHRS
        GO TO 9
C
    6   CALL G4NEXC(IDATA,IPOSS,IPOSS,NCHRS,+3,IPOSN)
        IF (IPOSN.NE.0) GO TO 902
        GO TO 2
C
C          IF (UPPER -> LOWER) OR (LOWER -> UPPER) CASE CONVERSION
C          IS SET, THE CHARACTER CODE IS ADJUSTED BEFORE COPYING.
C
    7   IF (.NOT.LOWER)   GO TO 8
        IF (KCHAR.LT. 65) GO TO 9
        IF (KCHAR.GT. 90) GO TO 9
C
        KCHAR= KCHAR+32
        GO TO 9
C
    8   IF (.NOT.UPPER)   GO TO 9
        IF (KCHAR.LT. 97) GO TO 9
        IF (KCHAR.GT.122) GO TO 9
C
        KCHAR= KCHAR-32
    9   LIMIT= LIMIT+1
        IDATA(LIMIT)= KCHAR
        CHDONE= .TRUE.
        GO TO 2
C
C          THIS SECTION IS ENTERED WHEN A SINGLE SWITCH-CHARACTER IS
C          ENCOUNTERED IN NORMAL MODE. THE INPUT CHARS. ARE DECODED
C          AS COMMANDS UNTIL ANOTHER SINGLE SWITCH-CHARACTER IS FOUND.
C
C          WHEN COMMAND MODE IS FIRST ENTERED, THE CHARACTER BUFFER
C          IS WRITTEN, AND ALL THE CHARACTER CONDITIONS ARE FOUND
C          VIA <ENQCHR> AND STORED. <CHANGD> IS SET TO ENSURE THAT
C          THESE CONDITIONS ARE CORRECTLY RESET AT SUBROUTINE EXIT.
C
   10   IF (LIMIT.LE.0) GO TO 11
C
        CALL G3LINK(2,11,-LIMIT,IDATA,RDATA)
        LIMIT= 0
   11   IF (CHANGD) GO TO 12
C
        CHANGD= .TRUE.
        CALL ENQLIN(IARG)
        LINTHK= IARG(2)
        KOLLIN= IARG(3)
        CALL ENQCHR(IARG,RARG)
        MLEVEL= 0
C
C          IF END-OF-BUFFER IS ENCOUNTERED DURING COMMAND MODE,
C          INITIAL CONDITIONS ARE RESET AND THE SUBROUTINE ENDS.
C          IF A SWITCH CHARACTER IS FOUND, NORMAL MODE IS RESET.
C          AN ERROR EXISTS IF IT IS A NUMBERED-CHARACTER SWITCH.
C
C          THE FIRST CALL TO <G4NEXC> FINDS THE POSITION OF THE
C          FIRST SUBSEQUENT SEPARATOR CHARACTER, AND THE SECOND
C          CALL GETS THE POSITION OF THE NEXT NON-SEPARATOR. IF
C          THERE ARE MULTIPLE SEPARATORS, THEY ARE ALL CHECKED.
C
   12   IF (IHERE.GT.NCHRS) GO TO 18
C
        CALL G4NEXC(IDATA,IHERE,NCHRS,NCHRS,+1,IPOSS)
        IF (IPOSS.LE.0) IPOSS= NCHRS+1
        GO TO 14
C
   13   IF (IHERE.GT.NCHRS) GO TO 18
C
        CALL G4NEXC(IDATA,IHERE,NCHRS,NCHRS,+1,IPOSS)
        IF (IPOSS.NE.IPOSN) GO TO 902
C
   14   CALL G4NEXC(IDATA,IHERE,NCHRS,NCHRS,-1,IPOSN)
   15     IF (IPOSS.GE.IPOSN.AND.IPOSN.GT.0) GO TO 17
          IF (IDATA(IPOSS).EQ.NOWNUM)        GO TO 902
          IF (IDATA(IPOSS).EQ.NOWCOM)        GO TO 16
          IF (IPOSS.GE.NCHRS)                GO TO 18
          IPOSS= IPOSS+1
          GO TO 15
C
   16   IHERE= IPOSS
        GO TO 2
C
C          IF THERE REMAINS ONLY ONE COMMAND LETTER IN THE
C          CHAR. BUFFER, AN ERROR IS SIGNALLED; OTHERWISE
C          A COMMAND PAIR IS MADE BY ADDING THE NEXT LETTER.
C
   17 IF (IPOSN.GE.NCHRS) GO TO 902
C
      KCHAR= IDATA(IPOSN)
      IF (KCHAR.GE.97.AND.KCHAR.LE.122) KCHAR= KCHAR-32
C
      ICOMND(1)= KCHAR
      IPOSN= IPOSN+1
      KCHAR= IDATA(IPOSN)
      IF (KCHAR.GE.97.AND.KCHAR.LE.122) KCHAR= KCHAR-32
C
      ICOMND(2)= KCHAR
      IPOSN= IPOSN+1
C
C          THE FOLLOWING SECTION THEN SELECTS THE OPERATION (IF
C          IT EXISTS), DECODES ANY ARGUMENTS, THEN PERFORMS IT.
C
      DO 200 ITEST= 1,14
        IF (ICOMND(1).EQ.ICODE(1,ITEST).AND.
     &      ICOMND(2).EQ.ICODE(2,ITEST))
     &            GO TO (1001,1002,1003,1004,1005,1006,1007,
     &                   1008,1009,1010,1011,1012,1013,1014), ITEST
  200 CONTINUE
      GO TO 902
C
C          THIS SECTION IS ENTERED AT THE END TO ENSURE
C          THAT THE BUFFER HAS BEEN COMPLETELY EMPTIED.
C
   18 END= .TRUE.
      IF (LIMIT.GT.0) CALL G3LINK(2,11,-LIMIT,IDATA,RDATA)
      GO TO 1009
C
C
C          THE COMMANDS ARE AS FOLLOWS:
C
C          1) ALLOW BOTH UPPER AND LOWER CASE (BC).
C
 1001 LOWER= .FALSE.
      UPPER= .FALSE.
      GO TO 20
C
C          2) SET LINE COLOUR n (COn).
C
 1002 CALL G4NEXI(IDATA,IHERE,NCHRS,NCHRS,IVALUE,LENGTH,IPOSN)
      IF (IVALUE.LT.0) IVALUE= IVALUE+1
      IF (LENGTH.LE.0) GO TO 902
C
      CALL LINCOL(IVALUE)
      GO TO 20
C
C          3) SET CHARACTER  FONT n (FOn).
C
 1003 CALL G4NEXI(IDATA,IHERE,NCHRS,NCHRS,IVALUE,LENGTH,IPOSN)
      IF (IVALUE.LT.0) IVALUE= IVALUE+1
      IF (LENGTH.LE.0) GO TO 902
C
      CALL CTRFNT(IVALUE)
      GO TO 20
C
C          4) SET/REMOVE ITALIC (ITn).
C
 1004 CALL G4NEXI(IDATA,IHERE,NCHRS,NCHRS,IVALUE,LENGTH,IPOSN)
      IF (IVALUE.LT.0) IVALUE= IVALUE+1
      IF (LENGTH.LE.0) GO TO 902
C
      CALL ITALIC(IVALUE)
      GO TO 20
C
C          5) CONVERT TO LOWER CASE (LC).
C
 1005 LOWER= .TRUE.
      UPPER= .FALSE.
      GO TO 20
C
C          6) SET CHARACTER MAGNIFICATION n (MAn).
C
 1006 CALL G4NEXI(IDATA,IHERE,NCHRS,NCHRS,IVALUE,LENGTH,IPOSN)
      IF (IVALUE.LT.0) IVALUE= IVALUE+1
      IF (LENGTH.LE.0) GO TO 902
      IF (CHDONE) CALL HSPACE(-1)
C
      CALL CTRMAG(IVALUE)
      IF (CHDONE) CALL HSPACE(1)
      GO TO 20
C
C          7) SET 'NORMAL' CHARACTERS (NO).
C
 1007 CALL NORMAL
      MLEVEL= MLEVEL-1
      GO TO 20
C
C          8) SET CHARACTER OBLATENESS r (OBr).
C
 1008 CALL G4NEXR(IDATA,IHERE,NCHRS,NCHRS,RVALUE,LENGTH,IPOSN)
      IF (LENGTH.LE.0) GO TO 902
      IF (CHDONE) CALL HSPACE(-1)
C
      CALL CTROBL(RVALUE)
      IF (CHDONE) CALL HSPACE(1)
      GO TO 20
C
C          9) RESET ORIGINAL CONDITIONS (RE).
C
C          (THIS IS ALWAYS ENTERED AT SUBROUTINE CLOSE).
C
 1009 IF (.NOT.CHANGD) GO TO 19
      IF (MLEVEL.GT.0) THEN
C
        DO 300 LEVEL= 1,MLEVEL
          CALL NORMAL
  300   CONTINUE
C
      ENDIF
C
      MLEVEL= 0
      IF (CHDONE) CALL HSPACE(-1)
      IF (IARG(3).EQ.0) CALL CTRMAG(IARG(2))
      IF (IARG(3).NE.0) CALL CTRSIZ(RARG(5))
      IF (CHDONE) CALL HSPACE(1)
C
      UPPER= .FALSE.
      LOWER= .FALSE.
      CALL CTRFNT(IARG(1))
      CALL ITALIC(IARG(4))
      CALL UNDLIN(IARG(5))
      CALL CTROBL(RARG(6))
      CALL LINCOL(KOLLIN)
      CALL THICK(LINTHK)
   19 IF (.NOT.END) GO TO 20
C
      IPRINT= IPRSAV
      RETURN
C
C          10) SET SUFFIX CHARACTERS (SF).
C
 1010 CALL SUFFIX
      MLEVEL= MLEVEL+1
      GO TO 20
C
C          11) SET SUPERFIX CHARACTERS (SP).
C
 1011 CALL SUPFIX
      MLEVEL= MLEVEL+1
      GO TO 20
C
C          12) SET LINE THICKNESS n (THn).
C
 1012 CALL G4NEXI(IDATA,IHERE,NCHRS,NCHRS,IVALUE,LENGTH,IPOSN)
      IF (IVALUE.LT.0) IVALUE= IVALUE+1
      IF (LENGTH.LE.0) GO TO 902
C
      CALL THICK(IVALUE)
      GO TO 20
C
C          13) CONVERT TO UPPER CASE (UC).
C
 1013 UPPER= .TRUE.
      LOWER= .FALSE.
      GO TO 20
C
C          14) SET n UNDERLINES (ULn).
C
 1014 CALL G4NEXI(IDATA,IHERE,NCHRS,NCHRS,IVALUE,LENGTH,IPOSN)
      IF (IVALUE.LT.0) IVALUE= IVALUE+1
      IF (LENGTH.LE.0) GO TO 902
C
      CALL UNDLIN(IVALUE)
C
C          THIS SECTION UPDATES THE READ POSITION
C          DURING THE PROCESSING OF COMMAND-STRINGS.
C
   20 IF (IPOSN.LE.0) IPOSN= NCHRS+1
C
      IHERE= IPOSN
      GO TO 13
C
C          THE FOLLOWING ARE THE ERROR SECTIONS:
C
  901 NUMERR= 18
      IF (ERRON) CALL G0ERMS
C
      NCHRS= 255
      GO TO 1
C
  902 NUMERR= 20
      IF (ERRON) CALL G0ERMS
C
      KCHAR= IDATA(IHERE)
      SHOW= .TRUE.
      GO TO 9
C
      END
