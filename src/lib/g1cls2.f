      SUBROUTINE G1CLS2(IFUNCO,LENGTH,IDATA,RDATA)
C
C          ------------------------------------------------
C          ROUTINE NO. (1013)   VERSION (A8.8)    11:SEP:97
C          ------------------------------------------------
C
C          THIS PROVIDES CHARACTER-DRAWING OPERATIONS.
C
C
C          THE ARGUMENTS ARE AS FOLLOWS:
C
C          <IFUNCO> GIVES THE FUNCTION CODE:
C                   =  1, SET CHARACTER HARDWARE MODE (N),
C                   =  2, SELECT CHARACTER FONT       (N),
C                   =  3, SET CHARACTER MAGNIFICATION (N),
C                   =  4, SET STRING ORIENTATION      (RADIANS),
C                   =  5, SET CHARACTER ORIENTATION   (RADIANS),
C                   =  6, SET ITALIC MODE             (N),
C                   =  7, SET UNDERLINE NUMBER        (N),
C                   =  8, SET CHARACTER OBLATENESS    (X),
C                   =  9, SET MARKER CHARACTER        (N),
C                   = 10, DEFINE CHARACTER SPACE      (X1,X2,Y1,Y2),
C                   = 11, WRITE CHARACTER STRING      (STRING),
C                   = 12, MOVE CHARACTER POSITION     (I,N),
C                   = 13, SET CHARACTER WINDOW MODE   (N),
C                   = 14, SET CHARACTER MASKING MODE  (N),
C                   = 15, STACK CHARACTER DEFINITIONS (N),
C                   = 16, REDEFINE FONT-0 CHARACTER   (N,IP1,...IPK).
C                   = 17, SET JUSTIFICATION TYPE      (N)
C          <LENGTH> GIVES THE DATA LENGTH (IN BYTES),
C          [IDATA]  IS THE INTEGER DATA ARRAY, AND
C          [RDATA]  IS THE ALTERNATIVE REAL DATA ARRAY.
C
C
      REAL    RDATA(*)
      INTEGER IDATA(*)
      LOGICAL LINSAV
      LOGICAL TYPMOD,KHRDW1,LHRDW1,WINLIN,WNDOIN,MASKIN,ERRON,PSPP
C
      COMMON /T1C2SV/ LPSAV(4)
      COMMON /T1CANG/ STANG1,CRANG1
      COMMON /T1CANU/ STANGU,CRANGU
      COMMON /T1CATT/ IUNDL1,ITAL1
      COMMON /T1CDCC/ SINCHR,COSCHR
      COMMON /T1CDCS/ SINSTR,COSSTR
      COMMON /T1CDEF/ KSTRT,NDEFS,KNUM(30),KPOSN(30),KLEN(30),KSPEC(500)
      COMMON /T1CDIM/ MAGN1,OBLAT1
      COMMON /T1CFIN/ INDLEN(2,256), WIDCHR(256)
      COMMON /T1CFON/ KFONT1
      COMMON /T1CJUS/ JUSTYP
      COMMON /T1CMOD/ TYPMOD
      COMMON /T1CMOV/ ADDSP,ADDLN
      COMMON /T1CSPA/ X1CHR1,X2CHR1,Y1CHR1,Y2CHR1
      COMMON /T1CVIS/ KWIND1,KMASK1
      COMMON /T1HRDC/ KHRDW1
      COMMON /T1HRDL/ LHRDW1
      COMMON /T1LPAT/ MARKA1,MISSA1,MARKB1,MISSB1
      COMMON /T1LVIS/ WINLIN,WNDOIN,MASKIN
      COMMON /T1MRKS/ MARKC1
      COMMON /T1POSP/ PSPP
      COMMON /T3CONS/ PI
      COMMON /T3ERRS/ ERRON,NUMERR
      COMMON /T3LIMS/ IMAXI,RMAXI,RMINI
C
      DATA LIMCHR /30/, LIMDEF /500/
C
C          THE FOLLOWING ARE STATEMENT FUNCTIONS TO CONVERT AN
C          ANGLE (RADIANS) INTO A QUADRANT NO., AND TO CONVERT
C          A QUADRANT NO. INTO A CARDINAL DIRECTION (RADIANS):
C
      KQUADR(STANG1)= (STANG1*2.0/PI)+0.5
      QUADR(STANG1)= 0.5*PI*KQUADR(STANG1)
C
C
      IF (IFUNCO.LT.1.OR.IFUNCO.GT.17) RETURN
      GO TO (1,2,3,4,5,6,7,8,9,10,14,21,22,23,24,26,31), IFUNCO
C
C          THIS SETS HARDWARE/SOFTWARE CHARS.
C
    1 KHRDW1= .FALSE.
      IF (IDATA(1).EQ.1) KHRDW1= .TRUE.
C
      CALL G1HRDW(6)
      CALL G1HRDW(7)
      GO TO 11
C
C          THIS SETS THE FONT NUMBER.
C
    2 IF (KFONT1.EQ.IDATA(1)) RETURN
      IF (.NOT.PSPP.AND.IDATA(1).GE.101) RETURN
C
      KFONT1= IDATA(1)
      IF (KFONT1.GT.3.AND.KFONT1.LT.11) KFONT1= 1
      IF (KFONT1.GT.25.AND.KFONT1.LT.101) KFONT1= 1
      IF (KFONT1.GT.113) KFONT1= 1
      IF (KFONT1.GE.11) CALL G1CHIO(1,0)
      IF (KFONT1.GE.101) THEN
        CALL G1HRDW(6)
        CALL G1HRDW(7)
        GO TO 11
      ENDIF
C
      RETURN
C
C          THIS SETS THE CHARACTER MAGNIFICATION.
C
    3 MAGN1= IDATA(1)
      GO TO 13
C
C          THIS SETS THE NOMINAL CHAR. STRING ANGLE.
C
    4 STANG1= RDATA(1)
      GO TO 11
C
C          THIS SETS THE NOMINAL CHAR. ROTATION ANGLE.
C
    5 CRANG1= RDATA(1)
      GO TO 12
C
C          THIS SETS ITALIC MODE.
C
    6 ITAL1= IDATA(1)
      IF (ITAL1.LT.0) ITAL1= 0
      IF (ITAL1.GT.1) ITAL1= 1
      CALL G1HRDW(6)
C
      RETURN
C
C          THIS SETS THE NUMBER OF UNDERLINES.
C
    7 IUNDL1= IDATA(1)
      IF (IUNDL1.LT.0) IUNDL1= 0
      IF (IUNDL1.GT.2) IUNDL1= 2
      RETURN
C
C          THIS SETS THE CHARACTER OBLATENESS.
C
    8 OBLAT1= ABS(RDATA(1))
      CALL G1HRDW(7)
      GO TO 13
C
C          THIS SETS THE MARKER CHARACTER.
C
    9 MARKC1= IDATA(1)
      RETURN
C
C          THIS SETS THE CHARACTER SPACE. IF THE SPACE IS
C          NOT OF FINITE AREA, TYPEWRITER MODE IS DISABLED.
C
   10 X1CHR1= RDATA(1)
      X2CHR1= RDATA(2)
      Y1CHR1= RDATA(3)
      Y2CHR1= RDATA(4)
      TYPMOD= .TRUE.
      IF (ABS(X2CHR1-X1CHR1).LT.RMINI.OR.
     &    ABS(Y2CHR1-Y1CHR1).LT.RMINI) TYPMOD= .FALSE.
C
C          WHENEVER THE CHAR. SPACE OR ANGLES ARE CHANGED, THE
C          CURRENTLY-USED ANGLES ARE REDEFINED. THEY ARE THE
C          SAME AS THE NOMINAL ANGLES WHEN THE FORMAT IS FREE,
C          BUT IN TYPEWRITER MODE THESE ARE INSTEAD CONVERTED
C          TO THE NEAREST CARDINAL DIRECTIONS. WHEN HARDWARE
C          CHARACTERS ARE BEING DONE, THE CALL TO <G1HRDW>
C          SETS THE APPROPRIATE HARDWARE CHARACTER ROTATION.
C
   11 STANGU= STANG1
      IF (TYPMOD) STANGU= QUADR(STANG1)
C
      SINSTR= SIN(STANGU)
      COSSTR= COS(STANGU)
   12 CRANGU= STANG1+CRANG1
      IF (TYPMOD) CRANGU= STANGU+QUADR(CRANG1)
C
      SINCHR= SIN(CRANGU)
      COSCHR= COS(CRANGU)
      CALL G1HRDW(2)
C
C          THE CHARACTER AND LINE SPACINGS ARE THEN CALCULATED
C          USING THE FORMAT RATIOS OF 6:7 AND 10:7 RESPECTIVELY.
C          WHEN HARDWARE CHARS. ARE BEING DONE, THE CALL TO
C          <G1HRDW> SETS THE MOST SUITABLE HARDWARE CHAR. SIZE.
C          DEPENDING ON THE (RELATIVE) CHAR. ROTATION USED, THE
C          CHAR. AND LINE SPACINGS MAY HAVE TO BE INTERCHANGED.
C          THE INCREMENTS ARE ADJUSTED TO ENSURE CLOSE PACKING.
C          THE X AND Y COMPONENTS OF THE SPACINGS ARE THEN FOUND.
C
   13 ADDSP= MAGN1*8.571429E-4*OBLAT1
      IF (.NOT.KHRDW1.AND.KFONT1.GE.100)
     &  ADDSP= ADDSP*WIDCHR(33)
C
      CALL G1CHSP
      CALL G1HRDW(3)
      RETURN
C
C          THIS SECTION DRAWS A STRING OF CHARACTERS (LEAVING
C          THE CHAR. POSITION AT THE END). CHARACTERS ARE NOT
C          SUBJECT TO THE PROGRAM WINDOW OR MASK AREAS UNLESS
C          THESE OPTIONS HAVE BEEN ACTIVATED. IF A LINE PATTERN
C          HAS BEEN SET, FULL LINES ARE TEMPORARILY SUBSTITUTED.
C
   14 IF (KWIND1.EQ.0) WNDOIN= .FALSE.
      IF (KMASK1.EQ.0) MASKIN= .FALSE.
C
      LPSAV(1)= MARKA1
      LPSAV(2)= MISSA1
      LPSAV(3)= MARKB1
      LPSAV(4)= MISSB1
      MARKA1= 0
      MISSA1= 0
      MARKB1= 0
      MISSB1= 0
      LINSAV= LHRDW1
      LHRDW1= .FALSE.
      IF (LINSAV) CALL G1HRDW(1)
C
C          EACH CHAR. IS TAKEN IN TURN FROM THE (UNPACKED)
C          ARRAY [IDATA], <G1CHAR> DRAWS IT, THEN <G1MOVC>
C          INCREMENTS THE POSITION BY ONE SPACE. <RUBOUT>
C          AND ALL THE CONTROL CODES EXCEPT <BACKSPACE>
C          (CHARACTER CODES 0-7, 9-31 AND 127) ARE IGNORED.
C
      LENTH= IABS(LENGTH)
      IF (KFONT1.GE.11.AND..NOT.KHRDW1) GO TO 16
C
C          ADJUST START POSITION IF CENTRE OR RIGHT JUSTIFIED.
C
      IF (JUSTYP.EQ.1) CALL G1MOVC(4,LENTH-1)
      IF (JUSTYP.EQ.2) CALL G1MOVC(3,LENTH)
C
      DO 100 ICHAR= 1,LENTH
        NCHAR= IDATA(ICHAR)
        IF (KFONT1.EQ.0)  GO TO 15
        IF (NCHAR.EQ.127) GO TO 100
        IF (NCHAR.EQ.8)   CALL G1MOVC(3,1)
        IF (NCHAR.LT.32)  GO TO 100
C
   15   CALL G1CHAR(NCHAR)
        CALL G1MOVC(1,1)
  100 CONTINUE
C
      GO TO 20
C
C          FONTS 11 - 255 ARE HIGH-QUALITY FONTS.
C
C       SAVE CHARACTER WIDTH, RESTORE AFTER STRING DONE.
C
   16 SAVADS= ADDSP
      IF (JUSTYP.LE.0) GO TO 18
C
C       HANDLE CENTRE AND RIGHT JUSTIFICATION BY ADJUSTING START POSN.
C
      IF (LENTH.LT.2) GO TO 17
C
      DO 200 ICHR= 2,LENTH
        ADDSP= WIDCHR(IDATA(ICHR)+1)*SAVADS
        IF (KFONT1.GE.100) ADDSP= ADDSP/WIDCHR(33)
C
        CALL G1CHSP
        IF (JUSTYP.EQ.1) CALL G1MOVC(4,1)
        IF (JUSTYP.EQ.2) CALL G1MOVC(3,1)
  200 CONTINUE
C
   17 IF(JUSTYP.LT.2) GO TO 18
C
      ADDSP= WIDCHR(IDATA(1)+1)*SAVADS
      IF (KFONT1.GE.100) ADDSP= ADDSP/WIDCHR(33)
C
      CALL G1CHSP
      CALL G1MOVC(4,1)
      ADDSP= WIDCHR(IDATA(LENTH)+1)*SAVADS
      IF (KFONT1.GE.100) ADDSP= ADDSP/WIDCHR(33)
C
      CALL G1CHSP
      CALL G1MOVC(2,1)
      ADDSP= SAVADS
      CALL G1CHSP
      CALL G1MOVC(3,1)
C
C       CHARS. ARE NOW OUTPUT ONE BY ONE, EACH FOLLOWED BY A CALL OF
C       G1MOVC TO ADVANCE THE TYPING POSITION BY A SUITABLE AMOUNT
C
   18 ADDSP= WIDCHR(IDATA(1)+1)*SAVADS
      IF (KFONT1.GE.100) ADDSP= ADDSP/WIDCHR(33)
C
      CALL G1CHSP
      CALL G1MOVC(4,1)
C
      DO 300 ICHR= 1,LENTH
        NCHAR= IDATA(ICHR)
        IF (NCHAR.EQ.127) GO TO 300
        IF (NCHAR.NE.8) GO TO 19
        IF (ICHR.GT.1) ADDSP= PRVSP
        IF (ICHR.LE.1) ADDSP= SAVADS
C
        CALL G1CHSP
        CALL G1MOVC(3,1)
   19   IF (NCHAR.LT.32) GO TO 300
C
        ADDSP= WIDCHR(NCHAR+1)*SAVADS
        IF (KFONT1.GE.100) ADDSP= ADDSP/WIDCHR(33)
C
C       PRESERVE WIDTH IN CASE FOLLOWED BY BACKSPACE.
C
        PRVSP= ADDSP
        CALL G1CHSP
        CALL G1MOVC(2,1)
        CALL G1CHAR(NCHAR)
        CALL G1MOVC(2,1)
  300 CONTINUE
C
C       RESTORE INITIAL CHARACTER WIDTH
C
      ADDSP= SAVADS
      CALL G1CHSP
      CALL G1MOVC(2,1)
C
C          LASTLY, THE PREVIOUS STATE IS RESTORED.
C
   20 MARKA1= LPSAV(1)
      MISSA1= LPSAV(2)
      MARKB1= LPSAV(3)
      MISSB1= LPSAV(4)
      LHRDW1= LINSAV
      IF (LHRDW1) CALL G1HRDW(1)
C
      MASKIN= .TRUE.
      IF (.NOT.WINLIN) WNDOIN= .TRUE.
      RETURN
C
C          THIS DOES A MOVE OF THE CHARACTER-POSITION.
C
   21 CALL G1MOVC(IDATA(1),IDATA(2))
      RETURN
C
C          THIS SETS THE CHARACTER WINDOW MODE.
C
   22 KWIND1= 0
      IF (IDATA(1).NE.0) KWIND1= 1
      RETURN
C
C          THIS SETS THE CHARACTER MASKING MODE.
C
   23 KMASK1= 0
      IF (IDATA(1).NE.0) KMASK1= 1
      RETURN
C
C          THIS STACKS/UNSTACKS CHARACTER DEFINITIONS.
C
   24 IF (IDATA(1).NE.0) GO TO 25
C
C          THIS STACKS THE CURRENT DEFINITIONS.
C
      IF (NDEFS.LE.0) RETURN
C
      KSTRT= NDEFS+1
      KNUM(NDEFS)= KNUM(NDEFS)+1000
      RETURN
C
C          THIS UNSTACKS THE PREVIOUS DEFINITIONS.
C
   25 NDEFS= KSTRT-1
      IF (NDEFS.LE.0)                RETURN
C
      KNUM(NDEFS)= KNUM(NDEFS)-1000
      IF (KNUM(NDEFS)/1000.GT.0)     RETURN
C
      KSTRT= NDEFS
      LIMIT= NDEFS-1
      IF (LIMIT.LE.0)                RETURN
C
      DO 400 LOOK= 1,LIMIT
        IF (KNUM(KSTRT-1)/1000.GT.0) RETURN
C
        KSTRT= KSTRT-1
  400 CONTINUE
      RETURN
C
C          THIS REDEFINES CHARACTERS IN FONT-0. (ONLY
C          CHARACTERS NUMBERED 0 - 159 CAN BE REDEFINED).
C
C          THIS PART FINDS THE POSITION <INDCHR> IF
C          THE CHARACTER HAS ALREADY BEEN REDEFINED.
C
   26 NCHAR= IDATA(1)
      LNSPEC= IABS(LENGTH)-1
      IF (NDEFS-KSTRT.LT.0) GO TO 29
C
      INDCHR= 0
C
      DO 500 LOOK= KSTRT,NDEFS
        INDCHR= INDCHR+1
        IF (NCHAR.EQ.KNUM(LOOK)) GO TO 27
  500 CONTINUE
C
      GO TO 29
C
C          THIS PART DELETES A PREVIOUS DEFINITION
C          UNLESS THE NEW ONE HAS THE SAME LENGTH.
C
   27 IF (KLEN(INDCHR).EQ.LNSPEC) GO TO 30
      IF (INDCHR.EQ.NDEFS)        GO TO 28
C
      LIMIT1= KPOSN(INDCHR+1)+1
      LIMIT2= KPOSN(NDEFS)+KLEN(NDEFS)-1
      IOFSET= KLEN(INDCHR)
C
      DO 600 IFROM= LIMIT1,LIMIT2
        ITO= IFROM-IOFSET
        KSPEC(ITO)= KSPEC(IFROM)
  600 CONTINUE
C
      LAST= NDEFS-1
C
      DO 700 ITO= INDCHR,LAST
        KNUM(ITO)= KNUM(ITO+1)
        KLEN(ITO)= KLEN(ITO+1)
  700 CONTINUE
C
      LAST= NDEFS-2
      IF (INDCHR.GT.LAST) GO TO 28
C
      DO 800 ICHAR= INDCHR,LAST
        KPOSN(ICHAR+1)= KPOSN(ICHAR)+KLEN(ICHAR)
  800 CONTINUE
C
   28 NDEFS= NDEFS-1
C
C          THIS PART INSERTS THE NEW DEFINITION (IF IT
C          EXISTS) PROVIDED THERE IS SUFFICIENT SPACE.
C
   29 IF (LNSPEC.EQ.0) RETURN
C
      LEFT= LIMDEF
      IF (NDEFS.GT.0) LEFT= LIMDEF-(KPOSN(NDEFS)+KLEN(NDEFS))
      IF (NDEFS.GE.LIMCHR) GO TO 901
      IF (LNSPEC.GT.LEFT)  GO TO 901
C
      INDCHR= NDEFS+1
      KNUM(INDCHR)= NCHAR
      KLEN(INDCHR)= LNSPEC
      IF (INDCHR.GT.1) KPOSN(INDCHR)= KPOSN(NDEFS)+KLEN(NDEFS)
C
      NDEFS= NDEFS+1
   30 IFROM= 2
      LIMIT1= KPOSN(INDCHR)+1
      LIMIT2= LIMIT1+KLEN(INDCHR)
C
      DO 900 ITO= LIMIT1,LIMIT2
        KSPEC(ITO)= IDATA(IFROM)
        IFROM= IFROM+1
  900 CONTINUE
C
      RETURN
C
C          THIS PART ALTERS THE CURRENT JUSTIFICATION TYPE.
C          0 IS LEFT, 1 IS CENTRE, AND 2 IS RIGHT.
C
   31 JUSTYP= IDATA(1)
      RETURN
C
C          THIS WRITES OUT AN ERROR MESSAGE.
C
  901 NUMERR= 1004
      IF (.NOT.ERRON) RETURN
C
      CALL G1FILB(0,0,-84,0)
      CALL G1ERMS
C
      RETURN
      END
